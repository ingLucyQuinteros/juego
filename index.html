<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HackRace â€” War of the Worlds</title>
<style>
  :root{
    --bg:#071021; --panel:#051019; --ink:#dfe9f3; --ink2:#9fb8c6; --accent:#3ad6ff; --accent2:#ff5c7a;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--ink)}
  /* Layout dos columnas */
  #wrap{max-width:1200px;margin:0 auto;padding:10px;display:grid;grid-template-columns: 320px 1fr;gap:12px}
  /* Panel izquierdo (texto/UI) */
  #left{
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.06);
    border-radius:10px;padding:12px;
  }
  #timer{font-weight:800;color:var(--accent2);margin:4px 0 10px 0}
  .muted{color:var(--ink2)}
  #routes{margin:6px 0 10px 0}
  #terminal pre{
    background:#01050a; color:#9be3ff; border-radius:8px; padding:10px;
    min-height:120px; max-height:220px; overflow:auto; margin:8px 0 6px 0; white-space:pre-wrap;
  }
  #cmdRow{display:flex; gap:8px}
  #cmd{flex:1; background:#02121a; border:1px solid rgba(255,255,255,0.08); color:#9be3ff;
       padding:8px 10px; border-radius:8px; font-family:monospace}
  .btn{background:#0ea5a3;border:none;padding:8px 12px;border-radius:8px;color:#012020;font-weight:800;cursor:pointer}
  .btn.secondary{background:#1f2937;color:#fff}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  hr{border:none;border-top:1px solid rgba(255,255,255,0.08);margin:10px 0}
  /* Panel derecho (juego) */
  #gameBox{
    background:#021422; border-radius:10px; overflow:hidden; position:relative;
    border:1px solid rgba(255,255,255,0.06); box-shadow:0 12px 40px rgba(0,0,0,0.35);
    aspect-ratio: 3 / 2; /* 900x600 */
    display:flex; align-items:center; justify-content:center;
  }
  #game{width:100%; height:100%;}
  /* Responsive */
  @media (max-width: 980px){
    #wrap{grid-template-columns: 1fr}
  }
</style>
</head>
<body>

<div id="wrap">
  <!-- Columna IZQUIERDA: Texto/UI -->
  <div id="left">
    <h2 style="margin:6px 0 0 0">HackRace â€” <span class="muted">War of the Worlds</span></h2>
    <div id="timer">Tiempo restante: 2:30</div>

    <div class="row">
      <strong>Turno:</strong> <span id="turnLabel">P1</span>
      <button class="btn secondary" id="musicBtn">â–¶ï¸Ž MÃºsica</button>
      <button class="btn secondary" id="resetBtn">Reiniciar</button>
    </div>

    <hr/>

    <div>
      <strong>Comandos</strong>
      <div class="muted" id="p1cmd">â€¢ P1 (Atacante): <code>move &lt;Ciudad&gt;</code></div>
      <div class="muted" id="p2cmd" style="display:none">â€¢ P2 (Defensor): <code>block &lt;Ciudad&gt;</code></div>
    </div>

    <div style="margin-top:10px">
      <div><strong>Estado</strong></div>
      <div class="muted">P1 Pos: <span id="p1pos">-</span> â€¢ P2 Pos: <span id="p2pos">-</span> â€¢ Bloqueos P2: <span id="p2blocked">0</span></div>
    </div>

    <div style="margin-top:10px">
      <div><strong>Rutas disponibles</strong></div>
      <div id="routes" class="muted">--</div>
    </div>

    <div id="terminal">
      <div class="muted">Terminal (pulsa <strong>T</strong> para enfocar) â€” autocompletar con <strong>Tab</strong></div>
      <pre id="log">Iniciando HackRace: War of the Worldsâ€¦</pre>
      <div id="cmdRow">
        <input id="cmd" placeholder="Ej. move Santiago" autocomplete="off"/>
        <button class="btn" id="send">Enviar</button>
      </div>
    </div>

    <div class="muted" style="font-size:12px">Consejo: P1 intenta llegar a <strong>CENTRAL</strong>; P2 bloquea estratÃ©gicamente rutas claves.</div>
  </div>

  <!-- Columna DERECHA: Juego -->
  <div id="gameBox"><div id="game"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
/* ------------------ Phaser Config ------------------ */
const config = {
  type: Phaser.AUTO,
  parent: 'game',
  width: 900,
  height: 600,
  backgroundColor: '#071021',
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
  scene: { preload, create, update }
};
const game = new Phaser.Game(config);

/* ------------------ Estado global ------------------ */
let sceneRef;
let nodes = [];
let edges = [];
let traces = [];
let players = {};
let turn = 'p1';
let animInProgress = false;
let victory = false;
let timerEv = null;
let timeLeft = 150; // 2:30
let bgm;

/* ------------------ Preload ------------------ */
function preload(){
  // Fondo opcional: mapa.png (si no existe se genera patrÃ³n)
  this.load.image('map', 'mapa.png');

  // MÃºsica de fondo local â€” coloca musicFondo.mp3 junto a este HTML (o ajusta la ruta)
  this.load.audio('bgm', 'assets/musicFondo.mp3');

  // SFX
  //this.load.audio('win', 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_3a8a9937da.mp3?filename=success-1-6297.mp3');
  //this.load.audio('lose', 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_9dcbfffefb.mp3?filename=game-over-arcade-6435.mp3');

  // PartÃ­cula para fuegos artificiales
  const g = this.make.graphics({x:0,y:0,add:false});
  g.fillStyle(0xffffff,1); g.fillCircle(6,6,6); g.generateTexture('dot',12,12); g.clear();
}

/* ------------------ Create ------------------ */
function create(){
  sceneRef = this;

  // Fondo (mapa si existe; si no, patrÃ³n)
  if(this.textures.exists('map')){
    const bg = this.add.image(450,300,'map').setDisplaySize(900,600).setDepth(0);
  } else {
    const g = this.add.graphics().setDepth(0);
    g.fillStyle(0x071021,1).fillRect(0,0,900,600);
    for(let i=0;i<=600;i+=30){ g.lineStyle(1,0x0a2a3b,0.08).strokeLineShape(new Phaser.Geom.Line(0,i,900,i)); }
    for(let i=0;i<=900;i+=40){ g.lineStyle(1,0x0a2a3b,0.06).strokeLineShape(new Phaser.Geom.Line(i,0,i,600)); }
  }

  // Capas de dibujo
  this.edgeGraphics  = this.add.graphics().setDepth(1); // rutas
  this.traceGraphics = this.add.graphics().setDepth(2); // huellas P1
  this.pathGraphics  = this.add.graphics().setDepth(6); // animaciÃ³n de movimiento

  // Nodos (derecha/izquierda ya definidos para mapa mundial estilizado)
  nodes = [
    {id:'Lima', x:140, y:360},
    {id:'Santiago', x:200, y:440},
    {id:'Mexico', x:80, y:200},
    {id:'NY', x:300, y:120},
    {id:'Toronto', x:250, y:80},
    {id:'London', x:460, y:110},
    {id:'Paris', x:500, y:140},
    {id:'Berlin', x:540, y:160},
    {id:'Cairo', x:600, y:220},
    {id:'Dubai', x:700, y:240},
    {id:'Mumbai', x:740, y:330},
    {id:'Bangkok', x:780, y:360},
    {id:'Singapore', x:820, y:420},
    {id:'Tokyo', x:820, y:200},
    {id:'Sydney', x:860, y:520},
    {id:'CapeTown', x:480, y:500},
    {id:'Madrid', x:420, y:170},
    {id:'Berlin2', x:570, y:190}
  ];

  // Conexiones (grafo con alternativas y trampas)
  connect('Lima','Santiago'); connect('Lima','Mexico'); connect('Mexico','NY');
  connect('NY','Toronto'); connect('Toronto','London'); connect('NY','London');
  connect('London','Paris'); connect('Paris','Berlin'); connect('Berlin','Berlin2');
  connect('Berlin2','Cairo'); connect('Paris','Madrid'); connect('Madrid','London');
  connect('Cairo','Dubai'); connect('Dubai','Mumbai'); connect('Mumbai','Bangkok');
  connect('Bangkok','Singapore'); connect('Singapore','Sydney'); connect('Bangkok','Tokyo');
  connect('Tokyo','Sydney'); connect('CapeTown','Santiago'); connect('CapeTown','Lima');
  connect('CapeTown','Cairo'); connect('Madrid','CapeTown'); connect('NY','Madrid');
  connect('Mexico','Lima'); connect('Lima','CapeTown'); connect('London','Dubai'); connect('Madrid','Dubai');

  // Dibuja rutas y nodos (una vez)
  drawEdges();
  drawNodes();

  // Central (Sydney) resaltada
  sceneRef.meta = { id:'Sydney' };
  highlightCentral('Sydney');

  // Jugadores
  players.p1 = { id:'p1', name:'P1 (Atacante)', node:'Lima', color:0x3ad6ff, blocked:0 };
  players.p2 = { id:'p2', name:'P2 (Defensor)', node:'Sydney', color:0xff7b5c, blocked:0 };
  drawPlayers();

  // MÃºsica de fondo (autoplay puede ser bloqueado; se inicia con botÃ³n/primer interacciÃ³n)
  bgm = this.sound.add('bgm', { loop:true, volume:0.45 });

  // Timer
  startTimer();

  // UI handlers
  byId('send').addEventListener('click', onCommand);
  byId('cmd').addEventListener('keydown', e=>{ if(e.key==='Enter') onCommand(); if(e.key==='Tab'){ e.preventDefault(); doAutocomplete(); }});
  byId('resetBtn').addEventListener('click', resetGame);
  byId('musicBtn').addEventListener('click', toggleMusic);
  window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='t') byId('cmd').focus(); });

  // Primer estado UI
  updateRoutesUI();
  log('Listo. P1 ataca, P2 defiende. Es turno de P1.');
}

/* ------------------ Update (timer UI) ------------------ */
function update(){
  if(timeLeft>0 && !victory){
    const m = Math.floor(timeLeft/60);
    const s = Math.floor(timeLeft%60).toString().padStart(2,'0');
    byId('timer').textContent = `Tiempo restante: ${m}:${s}`;
  }
}

/* ------------------ Grafo helpers ------------------ */
function connect(a,b){ edges.push({a,b,blocked:false}); }
function findNode(id){ return nodes.find(n=>n.id===id); }
function findEdgesFrom(id){ return edges.filter(e=> e.a===id || e.b===id).map(e=>({other:e.a===id?e.b:e.a, edge:e})); }
function edgeOf(a,b){ return edges.find(e=> (e.a===a && e.b===b) || (e.a===b && e.b===a)); }

/* ------------------ DIBUJO ------------------ */
function drawEdges(){
  const g = sceneRef.edgeGraphics; g.clear();
  // Limpia candados antiguos
  sceneRef.children.list.filter(c=>c._isLockLabel).forEach(c=>c.destroy());

  edges.forEach(e=>{
    const A = findNode(e.a), B = findNode(e.b);
    const color = e.blocked ? 0xffbf40 : 0x3ad6ff;
    const alpha = e.blocked ? 0.24 : 0.42;
    g.lineStyle(4, color, alpha);
    g.beginPath(); g.moveTo(A.x, A.y); g.lineTo(B.x, B.y); g.strokePath();
    if(e.blocked){
      const mx = (A.x+B.x)/2, my=(A.y+B.y)/2;
      const lock = sceneRef.add.text(mx, my, 'ðŸ”’', {font:'14px Arial', color:'#ffd9a3'}).setOrigin(0.5).setDepth(5);
      lock._isLockLabel = true;
    }
  });
  redrawTraces();
}

function drawNodes(){
  // Crea cÃ­rculos + etiquetas una vez
  nodes.forEach(n=>{
    n.dot && n.dot.destroy();
    n.label && n.label.destroy();
    n.dot = sceneRef.add.circle(n.x, n.y, 14, 0x082a36).setStrokeStyle(2, 0x9be3ff, 0.9).setDepth(3);
    n.label = sceneRef.add.text(n.x, n.y-28, n.id, {font:'12px Arial', color:'#cfeff6'}).setOrigin(0.5).setDepth(3);
  });
}

function highlightCentral(id){
  const c = findNode(id);
  sceneRef.add.circle(c.x,c.y,28,0xff0000,0.28).setDepth(1);
  sceneRef.add.star(c.x,c.y,8,20,10,0xff0000,0.85).setDepth(3);
  sceneRef.add.text(c.x,c.y+34,'CENTRAL',{font:'16px Arial', color:'#ff5c7a'}).setOrigin(0.5).setDepth(3);
}

function redrawTraces(){
  const g = sceneRef.traceGraphics; g.clear();
  traces.forEach(t=>{
    const A = findNode(t.a), B = findNode(t.b);
    g.lineStyle(6, t.color, 0.95);
    g.beginPath(); g.moveTo(A.x,A.y); g.lineTo(B.x,B.y); g.strokePath();
    g.lineStyle(2, 0xffffff, 0.14);
    g.beginPath(); g.moveTo(A.x,A.y); g.lineTo(B.x,B.y); g.strokePath();
  });
}

function drawPlayers(){
  // Limpia sprites previos
  if(sceneRef.p1Sprite) sceneRef.p1Sprite.destroy();
  if(sceneRef.p2Sprite) sceneRef.p2Sprite.destroy();

  const n1 = findNode(players.p1.node);
  const n2 = findNode(players.p2.node);

  sceneRef.p1Sprite = sceneRef.add.circle(n1.x, n1.y, 10, players.p1.color).setStrokeStyle(2,0x002b36,1).setDepth(7);
  sceneRef.p2Sprite = sceneRef.add.circle(n2.x, n2.y, 10, players.p2.color).setStrokeStyle(2,0x2b0200,1).setDepth(7);

  byId('p1pos').textContent = players.p1.node;
  byId('p2pos').textContent = players.p2.node;
  byId('p2blocked').textContent = players.p2.blocked || 0;
}

/* ------------------ Timer ------------------ */
function startTimer(){
  if(timerEv) timerEv.remove();
  timeLeft = 150; victory = false;
  timerEv = sceneRef.time.addEvent({
    delay: 1000, loop:true,
    callback: ()=>{
      timeLeft--;
      if(timeLeft<=0 && !victory){
        victory = true;
        log('Â¡Tiempo agotado! P2 (Defensor) gana como mejor bloqueador ðŸŽ‰');
        //playLoseSound();
        launchFireworksAt(findNode(players.p2.node).x, findNode(players.p2.node).y);
        showVictoryOverlay(players.p2,'P2 gana: Â¡Mejor bloqueador!');
      }
    }
  });
}

/* ------------------ Comandos ------------------ */
function onCommand(){
  if(animInProgress || victory) return log('OperaciÃ³n no permitida ahora.');
  const raw = byId('cmd').value.trim();
  if(!raw) return;
  byId('cmd').value = '';
  const [verb, ...rest] = raw.split(/\s+/);
  const arg = rest.join(' ');
  const current = turn==='p1' ? players.p1 : players.p2;

  if(turn==='p1' && verb?.toLowerCase()==='move'){
    if(!arg) return log('Indica destino: move <Ciudad>');
    const target = arg;
    const options = findEdgesFrom(current.node).map(r=>r.other);
    if(!options.includes(target)) return log('Destino no disponible desde tu nodo actual.');
    const ed = edgeOf(current.node, target);
    if(ed.blocked) return log('Ruta bloqueada. P2 protegiÃ³ esta conexiÃ³n.');
    // animar y dejar huella
    animateMove(current, target, ()=>{
      traces.push({a: current.node, b: target, color: current.color});
      redrawTraces();
      current.node = target;
      drawPlayers();
      checkCentralReached(current, target);
      if(!victory){ turn='p2'; updateRoutesUI(); }
    });

  } else if(turn==='p2' && verb?.toLowerCase()==='block'){
    if(!arg) return log('Indica nodo a bloquear: block <Ciudad>');
    const target = arg;
    const options = findEdgesFrom(current.node).map(r=>r.other);
    if(!options.includes(target)) return log('No puedes bloquear ese nodo desde tu posiciÃ³n.');
    const ed = edgeOf(current.node, target);
    if(ed.blocked) return log('Esa ruta ya estÃ¡ bloqueada.');
    ed.blocked = true;
    players.p2.blocked = (players.p2.blocked || 0) + 1;
    drawEdges();
    log(`P2 bloqueÃ³ la ruta a ${target} ðŸ”’`);
    turn = 'p1'; updateRoutesUI();

  } else {
    log(`Comando invÃ¡lido para ${current.name}. Usa: ${turn==='p1' ? 'move <Ciudad>' : 'block <Ciudad>'}`);
  }
}

function animateMove(player, target, onComplete){
  animInProgress = true;
  const from = findNode(player.node), to = findNode(target);
  const pg = sceneRef.pathGraphics; pg.clear();

  sceneRef.tweens.addCounter({
    from:0, to:1, duration:900, ease:'Cubic.easeInOut',
    onUpdate: t=>{
      const v=t.getValue();
      pg.clear();
      pg.lineStyle(6, player.color, 0.95);
      pg.beginPath(); pg.moveTo(from.x,from.y);
      const cx = Phaser.Math.Interpolation.Linear([from.x,to.x], v);
      const cy = Phaser.Math.Interpolation.Linear([from.y,to.y], v);
      pg.lineTo(cx,cy); pg.strokePath();
      pg.lineStyle(2, 0xffffff, 0.14);
      pg.beginPath(); pg.moveTo(from.x,from.y); pg.lineTo(cx,cy); pg.strokePath();

      if(Math.random()<0.08){
        const spark = sceneRef.add.image(cx,cy,'dot').setTint(player.color).setScale(0.6).setDepth(8);
        sceneRef.tweens.add({targets:spark, alpha:0, scale:0.2, duration:360, onComplete:()=>spark.destroy()});
      }
    },
    onComplete: ()=>{
      pg.clear();
      animInProgress=false;
      onComplete && onComplete();
    }
  });
}

/* ------------------ Meta / Victoria ------------------ */
function checkCentralReached(player, nodeId){
  if(nodeId===sceneRef.meta.id && player.id==='p1'){
    victory = true;
    log('Â¡P1 ha invadido la CENTRAL! ðŸŽ‰');
    //playWinSound();
    const c = findNode(nodeId);
    launchFireworksAt(c.x,c.y);
    showVictoryOverlay(player,'P1 gana: Â¡InvasiÃ³n exitosa!');
    timerEv?.remove();
  }
}

function showVictoryOverlay(player, message){
  const w=config.width,h=config.height;
  const layer = sceneRef.add.rectangle(w/2,h/2,w,h,0x000000,0.45).setDepth(50);
  sceneRef.add.text(w/2,h/2-8,message,{font:'32px Arial',color:'#fff'}).setOrigin(0.5).setDepth(51);
  sceneRef.add.text(w/2,h/2+24,'Pulsa Reiniciar para jugar otra ronda',{font:'14px Arial',color:'#cfeff6'}).setOrigin(0.5).setDepth(51);
}

/* ------------------ Fuegos artificiales ------------------ */
function launchFireworksAt(x,y){
  const colors=[0xff5c7a,0x3ad6ff,0xffd36b,0x9b7bff,0x5cff9b];
  const parts = sceneRef.add.particles('dot');
  for(let i=0;i<7;i++){
    sceneRef.time.delayedCall(i*320, ()=>{
      const em = parts.createEmitter({
        x: x + Phaser.Math.Between(-20,20),
        y: y + Phaser.Math.Between(-20,20),
        speed:{min:120,max:320},
        angle:{min:0,max:360},
        scale:{start:1,end:0},
        lifespan:1000,
        gravityY:120,
        quantity:18,
        blendMode:'ADD',
        tint: colors[Phaser.Math.Between(0,colors.length-1)]
      });
      sceneRef.time.delayedCall(650, ()=> em.stop());
    });
  }
  sceneRef.time.delayedCall(3000, ()=> parts.destroy());
}

/* ------------------ Sonido ------------------ */
function toggleMusic(){
  try{
    console.log("se pudo reproducir music");
    if(!bgm.isPlaying){ bgm.play(); byId('musicBtn').textContent='â¸ï¸Ž MÃºsica'; }
    else { bgm.pause(); byId('musicBtn').textContent='â–¶ï¸Ž MÃºsica'; }
  }catch(e){
    console.log("no se puedo reproducir la music");
    log('No se pudo iniciar la mÃºsica. AsegÃºrate de tener musicFondo.mp3 junto a este archivo.');
  }
}
//function playWinSound(){ sceneRef.sound.play('win'); }
//function playLoseSound(){ sceneRef.sound.play('lose'); }

/* ------------------ UI helpers ------------------ */
function updateRoutesUI(){
  byId('turnLabel').textContent = turn.toUpperCase();
  byId('p1cmd').style.display = (turn==='p1')?'block':'none';
  byId('p2cmd').style.display = (turn==='p2')?'block':'none';
  const current = (turn==='p1')?players.p1:players.p2;
  const r = findEdgesFrom(current.node);
  const text = r.map(x=>`${x.other}${x.edge.blocked?' (BLOQUEADO)':''}`).join('  |  ') || '--';
  byId('routes').textContent = text;
  log(`${(turn==='p1'?'P1':'P2')} desde ${current.node}. Rutas: ${text}`);
}

function resetGame(){
  traces = [];
  victory = false;
  animInProgress = false;
  turn='p1';
  players.p1.node='Lima'; players.p1.blocked=0;
  players.p2.node='Sydney'; players.p2.blocked=0;
  edges.forEach(e=> e.blocked=false);
  sceneRef.children.list.filter(c=>c._isLockLabel).forEach(c=>c.destroy());
  sceneRef.edgeGraphics.clear(); sceneRef.traceGraphics.clear(); sceneRef.pathGraphics.clear();
  drawEdges(); drawNodes(); drawPlayers(); updateRoutesUI();
  startTimer();
  log('Juego reiniciado.');
}

/* Autocompletar con Tab: sugiere primer destino posible del turno actual */
function doAutocomplete(){
  const current = (turn==='p1')?players.p1:players.p2;
  const poss = findEdgesFrom(current.node).map(r=>r.other).filter(o=>!edgeOf(current.node,o)?.blocked || turn==='p2');
  if(poss.length===0) return;
  byId('cmd').value = (turn==='p1'?'move ':'block ')+poss[0];
  byId('cmd').focus();
}

/* ------------------ Util ------------------ */
function byId(id){ return document.getElementById(id); }
function log(msg){
  const pre=byId('log'); const now=new Date().toLocaleTimeString();
  pre.textContent += `\n[${now}] ${msg}`; pre.scrollTop=pre.scrollHeight;
}
</script>
</body>
</html>
